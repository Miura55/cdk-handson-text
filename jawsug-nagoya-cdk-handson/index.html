
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>JAWS-UG 名古屋 AWS CDKハンズオン</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="jawsug-nagoya-cdk-handson"
                  title="JAWS-UG 名古屋 AWS CDKハンズオン"
                  environment="web"
                  feedback-link="https://twitter.com/k_miura_io">
    
      <google-codelab-step label="はじめに" duration="0">
        <p>本資料はAWS Cloud Development Kit(CDK)を初めて触る方をターゲットにCDKの環境構築方法とCDKを使ってAWS上にアプリケーションをデプロイする方法を紹介します。</p>
<p>インフラ構成をコードで管理するIaC(Infrastracture as Code)をハンズオンを通じて体験していきましょう。</p>
<h2 is-upgraded>IaCとは</h2>
<p>IaCとはインフラのシステム構成をコードを用いて定義することをいいます。</p>
<p>インフラを構築するためには様々なアプリケーション、サービスをセットアップする必要がありますが、そのインフラの構成が複雑になればなるほど再構築が難しくなってきます。</p>
<p>そして手順書があっても見落として不具合につながる可能性も高くなります。</p>
<p>そのような問題を解決するのが「IaC(Infrastracture as Code)」です。</p>
<p>コードでインフラのシステム構成を定義することで必要なソフトウェアが自動的にセットアップされます。</p>
<p>これにより環境構築が自動化されるので、ヒューマンエラーを減らすだけではなく管理コストも大きく下げることができます。</p>
<h2 is-upgraded>AWS CDKとは</h2>
<p>AWS CDKはAWSのサービス構成をコードで定義するためのIaCツールです。クラウドのアプリケーション構成をモダンなプログラミング言語で定義することができて、最終的にはCloudFormationのテンプレートに変換されてデプロイをされます。</p>
<p>CDKを使って開発することで以下のようなメリットがあります。</p>
<ul>
<li>AWSのサービス構成をアプリケーションのコードと一緒にGitレポジトリと一緒に管理することができる→チームメンバーがインフラベースからアプリケーション構成を理解しやすくなる</li>
<li>共通で構築するリソース定義をモジュール化し、他のプロジェクトで使いまわしがしやすい</li>
<li>認証するAWSアカウントを変更することで、複数の環境で同じインフラ構成をデプロイできるため、再現性が高い</li>
</ul>
<h2 is-upgraded>このハンズオンで作るもの</h2>
<p>このハンズオンではシンプルなTodoアプリケーションの構築を通じてCDKの使い方、IaCの魅力を体験して頂きます。</p>
<p>Step1ではECS Fargate + API Gatewayを使ったAPIを構築します。</p>
<p>Step2ではDynamoDBのテーブルを用意して、Step1で構築したAPIに接続できるようにします。</p>
<p>Step3ではS3 + CloudFrontを使ってフロントエンドをホスティングしてStep1で構築したAPIで通信できるようにします。</p>
<p class="image-container"><img style="width: 396.00px" src="img/21c04ba073669aa2.png"></p>
<p>今回構築するアプリケーションの構造がわかったところで、次のページから環境構築していきます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="環境構築" duration="0">
        <p>今回のハンズオンの環境構築をやっていきます。</p>
<p>なお、リージョン違いでのトラブルを防ぐためAWSの作業はすべて<strong>ap-northeast-1(東京リージョン)</strong>で行います</p>
<h2 is-upgraded>事前準備</h2>
<ul>
<li>AWSアカウント(IAMユーザーでログインしている場合は、AdministratorAccessポリシーが必要です。AWSアカウントをお持ちで無い方は<a href="https://aws.amazon.com/jp/register-flow/" target="_blank">https://aws.amazon.com/jp/register-flow/</a> を参考に登録してください)</li>
</ul>
<h2 is-upgraded>EC2上にcode-serverを構築</h2>
<p>まずは開発環境を用意します。今回は環境の差異をなくすため、CDKの実行環境を構築したEC2インスタンス上で動作する<a href="https://github.com/coder/code-server" target="_blank">code-server</a> を用意します。code-serverはオンラインでVS Codeを動かすためのオープンソースのツールです。</p>
<p>手順を簡略化させるため、今回はこのcode-serverを動作させるための最小構成のセットアップをするCloudFormationテンプレートを使ったスクリプトを用意したので、それを使ってCDKの開発環境を構築していきます。</p>
<aside class="special"><p>お手元のローカル環境上でワークショップを進めても問題ありません。</p>
<p>その場合は、以下の動作環境を用意する必要があります。</p>
<ul>
<li>Node.js v20.10.0以上</li>
<li>AWS CDK v2.1029.0以上</li>
<li>CDK CLI v2.1029.1</li>
</ul>
<p>当然ですが、IAMのアクセスキーの設定もあらかじめ済ませておきましょう。</p>
</aside>
<p>AWSのマネジメントコンソールを開きCloudShellを開きます。</p>
<p>CloudShellは右上のターミナルアイコンから開くことができます。このとき、リージョンは<strong>アジアンパシフィック(東京)</strong>になっていることを確認してください。</p>
<p class="image-container"><img style="width: 355.00px" src="img/ff463146831f0c80.png"></p>
<p>CloudShellを開いたら、以下のコマンドでスクリプトが入ってるレポジトリをクローンしてきます。</p>
<pre><code>git clone https://github.com/Miura55/ec2-code-server.git</code></pre>
<p>クローンしたら以下のコマンドでスクリプトを起動します。</p>
<pre><code>cd ec2-code-server
./deploy.sh</code></pre>
<p>ここから対話形式でセットアップをします。まずは、SSH接続で必要なキーペアを設定する項目ですが、今回は特にSSH接続を行う必要はないので、何も入力せずEnterキーを入力します。</p>
<pre><code>Enter key pair name (optional, press Enter to skip): </code></pre>
<p>インスタンスタイプを設定します。特にこだわりが無ければデフォルトの <code>t3.medium</code> を設定し、Enterキーを入力します。</p>
<pre><code>Instance type (t3.medium): </code></pre>
<p><br>AMIはAmazon Linux 2023のAMI IDがデフォルトで設定されています。このままで問題なければEnterキーを入力します。</p>
<pre><code>AMI ID (ami-07faa35bbd2230d90):</code></pre>
<p>続いてパスワードの設定です。パスワードは自分が覚えやすいものを設定し、Enterキーを入力します。</p>
<p>※入力内容が非表示になる設定を入れています。</p>
<pre><code>VSCode Server password (vscode-password):</code></pre>
<p>CIDRは <code>0.0.0.0/0</code> を設定し、Enterキーを入力します。</p>
<pre><code>Allowed CIDR (0.0.0.0/0):</code></pre>
<p>以上の設定を行うと、CloudFormation上に <code>vscode-cdk-dev</code> という名前のスタックが作成されます。</p>
<p>リソースの作成状況はマネコンのCloudFormationの画面で確認できます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/702227aef004424f.png"></p>
<p>作成が完了するとCloudShellから以下の出力がされたら、スタックの作成は正常に完了しています。</p>
<pre><code>--------------------------------------------------------------------------------------------------------------------------
|                                                     DescribeStacks                                                     |
+-----------------------------------------+-----------------------+------------------------------------------------------+
|               Description               |       OutputKey       |                     OutputValue                      |
+-----------------------------------------+-----------------------+------------------------------------------------------+
|  EC2 Instance ID                        |  InstanceId           |  i-03abcdef10caf14e2                                 |
|  Public IP address of the instance      |  PublicIP             |  11.111.111.11                                       |
|  Password for VSCode Server             |  VSCodeServerPassword |  vscode-serer                                        |
|  URL to access VSCode Server            |  VSCodeServerURL      |  http://11.111.111.11:8080                           |
+-----------------------------------------+-----------------------+------------------------------------------------------+
</code></pre>
<p>この出力の中にある <code>VSCodeServerURL</code> の値をコピーし、ブラウザで開くと以下の画面が表示されます。ここで、<code>VSCodeServerPassword</code>  で設定したパスワードを入力します。</p>
<p class="image-container"><img style="width: 601.70px" src="img/76888277ab01fdd6.png"></p>
<p>以下の通りVS Codeの画面が表示されていればオンラインの開発環境は構築されています。</p>
<p class="image-container"><img style="width: 601.70px" src="img/537868ca8bb5cee9.png"></p>
<h2 is-upgraded>CDKのプロジェクトを作成する</h2>
<p>実行環境を用意できたところで、今回使用するCDKのプロジェクトの雛形を用意します。CDKのプロジェクトを作るためには空のディレクトリを用意する必要があるので以下のコマンドでディレクトリを用意します。</p>
<pre><code>mkdir cdk-handson
cd cdk-handson</code></pre>
<p><code>pwd</code> と入力したときに以下のパスが表示されたら問題ありません。</p>
<pre><code>/home/ec2-user/cdk-handson</code></pre>
<p>空のディレクトリが用意できたところで以下のコマンドを実行しCDKアプリを用意します。</p>
<pre><code>cdk init app --language typescript</code></pre>
<p>CDKプロジェクトが用意できたので、作業を円滑に行うためにエディタでCDKのプロジェクトがあるディレクトリを開きます。左のメニューバーにあるファイルアイコンをクリックし、「Open Folder」をクリックします。</p>
<p class="image-container"><img style="width: 342.00px" src="img/fd8fe2fac3d468dc.png"></p>
<p>開くフォルダを聞かれるので、 <code>/home/ec2-user/cdk-handson</code> を入力し、OKボタンを押します。</p>
<p class="image-container"><img style="width: 596.00px" src="img/5dc3a70075c6f7ca.png"></p>
<p>以下の構成のファイルが表示されたら、開発環境の準備は完了です。</p>
<p class="image-container"><img style="width: 299.00px" src="img/6bf6a6b816db316.png"></p>
<h2 is-upgraded>Bootstrap</h2>
<p>CDKでデプロイする前にAWS側でデプロイ時のデータを保持するためのリソースを用意する必要があります。これを <strong>Bootstrap</strong> といいます。</p>
<p>環境構築の最後の作業として以下のコマンドでBootstrapを実行します</p>
<aside class="special"><p>すでにデプロイ先のAWSアカウントでCDKを使用したことがある場合は、この手順はスキップしてOKです。</p>
</aside>
<pre><code>cdk bootstrap</code></pre>
<p>実行後各種リソースが作成されて以下のようなメッセージが表示されたらBootstrapは正常に完了しています。</p>
<pre><code>CDKToolkit: creating CloudFormation changeset...
 ✅  Environment aws://123456789000/ap-northeast-1 bootstrapped.</code></pre>
<p>ちなみにAWSのコンソールでCloudFormationを確認すると、以下のように「CDKToolkit」という名前のスタックが作られていますが、これがCDKでデプロイするときのデータを保持しておくリソースが作成されています。余裕がある方はスタックを開いていただき、どんなリソースが作成されているか見てみるといいです。</p>
<p class="image-container"><img style="width: 601.70px" src="img/be01fd003e8cd03e.png"></p>
<p>以上で環境構築は完了です。次のページからCDKを使ってAWSのアプリケーションを構築していきます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step1. APIを構築する" duration="0">
        <p>ここからCDKを使ってアプリケーションを構築していきます。まずはVPCを構築してECS Fargateを使ったAPIを構築していきます。</p>
<h2 is-upgraded>ソースコードをダウンロード</h2>
<p>前のページで作成したCDKアプリのディレクトリ( <code>cdk-handson</code> )上で以下のコマンドを実行してAPIのソースコードをダウンロードして展開します。</p>
<pre><code>wget -O api.zip https://github.com/Miura55/jawsug-nagoya-cdk-handson/releases/download/v1.0.0/api-asset-v1.0.0.zip
unzip api.zip</code></pre>
<p>展開して以下のように <code>cdk-handson</code> 配下に <code>api</code> ディレクトリが作成されたら問題ありません。</p>
<p class="image-container"><img style="width: 299.00px" src="img/f1157e1326407a5b.png"></p>
<h2 is-upgraded>APIを構築するコンストラクトのコード</h2>
<p>APIのコードを用意できたら、ターミナルを開きます。</p>
<p>以下のコマンドで今回作成するアプリケーションの各ステップで作成するリソースを定義したモジュール(以下、コンストラクト)を保存するディレクトリを作成します。</p>
<pre><code>mkdir -p lib/constructs/</code></pre>
<p>続いてAPIのコンストラクトのファイルを以下のコマンドで新規作成します。</p>
<pre><code>touch lib/constructs/api-construct.ts</code></pre>
<p><code>lib/constructs/api-construct.ts</code> に以下のコードを書き込みます。</p>
<pre><code>import { Construct } from &#39;constructs&#39;;
import { HttpApi, CorsHttpMethod, HttpMethod, VpcLink } from &#39;aws-cdk-lib/aws-apigatewayv2&#39;;
import { HttpAlbIntegration } from &#39;aws-cdk-lib/aws-apigatewayv2-integrations&#39;;
import * as cdk from &#39;aws-cdk-lib&#39;;
import { SecurityGroup, Vpc, Port, Peer } from &#39;aws-cdk-lib/aws-ec2&#39;;
import { Cluster, ContainerImage, LogDriver } from &#39;aws-cdk-lib/aws-ecs&#39;;
import { DockerImageAsset } from &#39;aws-cdk-lib/aws-ecr-assets&#39;;
import { ApplicationLoadBalancedFargateService } from &#39;aws-cdk-lib/aws-ecs-patterns&#39;;
import { RetentionDays } from &#39;aws-cdk-lib/aws-logs&#39;;
import { IRole } from &#39;aws-cdk-lib/aws-iam&#39;;

interface ApiProps {
  tableName: string;
}

export class ApiConstruct extends Construct {
  public readonly apiEndpoint: string;
  public readonly fargateTaskRole: IRole;

  constructor(scope: Construct, id: string, props: ApiProps) {
    super(scope, id);

    // VPC
    const vpc = new Vpc(this, &#39;Vpc&#39;, {
      maxAzs: 2,
    });

    // ECS Cluster
    const cluster = new Cluster(this, &#39;Cluster&#39;, {
      clusterName: &#39;handson-api-cluster&#39;,
      vpc: vpc,
    });


    // VPC Link用のセキュリティグループを作成
    const vpcLinkSecurityGroup = new SecurityGroup(this, &#39;VpcLinkSecurityGroup&#39;, {
      vpc: cluster.vpc,
      description: &#39;Security group for VPC Link&#39;,
      allowAllOutbound: true, // ALBへのアウトバウンド通信を許可
    });

    // ALBへのアクセスを許可（ALBがポート80でリッスンしている場合）
    vpcLinkSecurityGroup.addEgressRule(
      Peer.anyIpv4(),
      Port.tcp(80),
      &#39;Allow outbound HTTP to ALB&#39;
    );

    // または、ALBがポート8000でリッスンしている場合
    vpcLinkSecurityGroup.addEgressRule(
      Peer.anyIpv4(),
      Port.tcp(8000),
      &#39;Allow outbound to ALB on port 8000&#39;
    );

    // VPC Linkを明示的に作成（セキュリティグループを指定）
    const vpcLink = new VpcLink(this, &#39;ApiVpcLink&#39;, {
      vpc: cluster.vpc,
      subnets: {
        subnets: cluster.vpc.privateSubnets,
      },
      securityGroups: [vpcLinkSecurityGroup], // 作成したセキュリティグループを指定
    });

    // Docker Image Asset
    const imageAsset = new DockerImageAsset(this, &#39;ImageAsset&#39;, {
      directory: &#39;./api&#39;,
    });

    // ALB付きFargateサービス
    const fargateService = new ApplicationLoadBalancedFargateService(this, &#39;FargateService&#39;, {
      cluster,
      memoryLimitMiB: 512,
      cpu: 256,
      taskImageOptions: {
        image: ContainerImage.fromDockerImageAsset(imageAsset),
        containerPort: 8000,
        enableLogging: true,
        logDriver: LogDriver.awsLogs({
          streamPrefix: &#39;handson-api&#39;,
          logRetention: RetentionDays.ONE_DAY,
        }),
        environment: {
          &#39;AWS_REGION&#39;: cdk.Stack.of(this).region,
          &#39;DYNAMO_TABLE&#39;: props.tableName,
        },
      },
      taskSubnets: {
        subnets: cluster.vpc.privateSubnets,
      },
      listenerPort: 8000, // ALBリスナーを8000ポートに設定
    });

    // ヘルスチェックパスを設定
    fargateService.targetGroup.configureHealthCheck({
      path: &#39;/&#39;,
    });

    // ALB Integration
    const albIntegration = new HttpAlbIntegration(&#39;HttpApiIntegration&#39;, fargateService.listener, {
      vpcLink: vpcLink
    });

    // HTTP API
    const httpApi = new HttpApi(this, &#39;HttpApi&#39;, {
      apiName: &#39;handson-api&#39;,
      corsPreflight: {
        allowOrigins: [&#39;*&#39;],
        allowHeaders: [&#39;*&#39;],
        allowMethods: [CorsHttpMethod.ANY],
      },
    });

    // Routes
    httpApi.addRoutes({
      path: &#39;/{proxy+}&#39;,
      methods: [HttpMethod.ANY],
      integration: albIntegration,
    });

    // Output
    new cdk.CfnOutput(this, &#39;ApiEndpoint&#39;, {
      value: httpApi.apiEndpoint,
    });

    // スタックの外から参照できるようにする
    this.apiEndpoint = httpApi.apiEndpoint;
    this.fargateTaskRole = fargateService.taskDefinition.taskRole;
  }
}
</code></pre>
<p>用意したコンストラクトをスタックに反映するために、 <code>lib/cdk-handson-stack.ts</code> を以下のコードに書き換えます。</p>
<pre><code>import * as cdk from &#39;aws-cdk-lib&#39;;
import { Construct } from &#39;constructs&#39;;
import { ApiConstruct } from &#39;./constructs/api-construct&#39;;

export class CdkHandsonStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const tableName = &#39;cdk-handson-todo&#39;;

    // API Construct
    const api = new ApiConstruct(this, &#39;Api&#39;, {
      tableName: tableName
    })
  }
}
</code></pre>
<p>ここで変数 <code>api</code> を定義していますが、これは後で作成するスタックで必要になるのでそのままにしておいてください。</p>
<h2 is-upgraded>テンプレートの作成</h2>
<p>CDKはコードで書いたスタックをCloudFormationのテンプレートに変換してAWSにデプロイします。そこで実際にこのステップで用意したスタックでどんなテンプレートが作成されるかを見てみます。</p>
<p><code>cdk-handson</code> ディレクトリ上で以下のコマンドを実行するとCloudFormationのテンプレートが実行結果に出力されます。</p>
<pre><code>cdk synth</code></pre>
<p>実行結果ではYaml形式でテンプレートが出力されます。実際に書いたコードよりも膨大な量のテンプレートが作成されることがおわかりいただけると思います。CDKでデプロイをするのであれば <code>cdk deploy</code> 時にCloudFormationのテンプレートは作成されるので、このコマンドを実行する必要はありません。</p>
<h2 is-upgraded>デプロイ</h2>
<p>それではAWSにデプロイしてみましょう。デプロイは以下のコマンドを実行します</p>
<pre><code> cdk deploy</code></pre>
<p>実行するとAPIのコンテナイメージのビルドが実行されて先程Bootstrapで作成されたECRレポジトリにPushします。その後作成されるAWSのリソースが一覧で表示され、以下の質問が表示されるので、 <code>y</code> と入力してエンターキーを押すと次に進みます。</p>
<pre><code>Do you wish to deploy these changes (y/n)? </code></pre>
<p>以下のようにAWSのリソースが自動で構築されていきます。初回はデプロイに時間がかかります。</p>
<p class="image-container"><img style="width: 601.70px" src="img/c769fd1d896111e0.png"></p>
<p>デプロイが完了し、以下のように出力が表示されたらデプロイは正常に完了しています。</p>
<p><code>ApiEndpoint</code> は今後の手順で必要になるのでどこかにメモしておきます。</p>
<pre><code>Outputs:
CdkHandsonApiStack.ApiEndpoint = https://odbhg8has3.execute-api.ap-northeast-1.amazonaws.com
CdkHandsonApiStack.FargateServiceLoadBalancerDNS8987E = CdkHa-Farga-D6UWOZCNQBIG-184184.ap-northeast-1.elb.amazonaws.com
CdkHandsonApiStack.FargateServiceServiceURL454545 = http://CdkHa-Farga-A3HZCNQBIG-3212312.ap-northeast-1.elb.amazonaws.com
</code></pre>
<h2 is-upgraded>動作確認</h2>
<p>それでは動作確認です。</p>
<p>先程のデプロイ後の出力の中にある <code>CdkHandsonApiStack.ApiEndpoint</code> の値にあるURLを開くと以下のJSONが表示されます。</p>
<pre><code>{
  message: &#34;Hello World&#34;
}
</code></pre>
<p>今回デプロイしたAPIはAPIドキュメントを用意しています。APIドキュメントはブラウザで  <code>[CdkHandsonApiStack.ApiEndpoint]/docs</code> を入力すると開きます。ここにあるAPIが今回構築するアプリケーションで使うものです。</p>
<p class="image-container"><img style="width: 601.70px" src="img/70582ed6b21acf09.png"></p>
<p>先程に開いたJSONのAPIが <code>GET /</code> で、ALBのヘルスチェックやAPIの動作確認用途のAPIです。</p>
<p>APIドキュメントで動作確認をするには、動作確認したいAPIのアコーディオンを開いて <code>Try it out</code> ボタンを押すと表示される <code>Execute</code> ボタンを押すことでAPIを実行することができます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/4ae0216139898ba1.png"></p>
<p>その他のAPIはDynamoDBのデータを取得・書き込み・削除するAPIですが、このAPIは現状動作しないはずです。試しに <code>GET /messages</code> を実行してみると、以下のようにステータスコード <code>500</code> を返します。</p>
<p class="image-container"><img style="width: 601.70px" src="img/e06f4ebfdf8b5bd8.png"></p>
<p>500を返す原因はデプロイしたAPIの中でDynamoDBにアクセスするためのロールが割り当てられてないのとそもそもまだDynamoDBのテーブルが作成されていないからです。</p>
<p>というわけで次のステップでは、このDynamoDBのテーブルを作成して、このAPIに接続できるようにしていきます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step2. DynamoDBをAPIに接続する" duration="0">
        <p>Step1でAPIを作成しましたが、DynamoDBのテーブルが作成されていないことでエラーになっていました。そこでこのステップでは今回のアプリケーションに使用するDynamoDBのテーブルの作成とそれをAPIに接続するためのスタックを用意します。</p>
<h2 is-upgraded>データベースを構築するコンストラクトのコード</h2>
<p>APIのスタックと同様に <code>cdk-handson/lib</code> ディレクトリ内にデータベースを構築するためのコンストラクトを用意します。</p>
<p>以下のコマンドでコンストラクトのコードを新規作成します。</p>
<pre><code>touch lib/constructs/database-construct.ts</code></pre>
<p><code>lib/constructs/database-construct.ts</code> に以下のコードを書いて保存します。</p>
<pre><code>import * as cdk from &#34;aws-cdk-lib&#34;;
import { Construct } from &#34;constructs&#34;;
import { Table, AttributeType, BillingMode } from &#34;aws-cdk-lib/aws-dynamodb&#34;;
import { IRole } from &#34;aws-cdk-lib/aws-iam&#34;;

interface DatabaseConstructProps extends cdk.StackProps {
  tableName: string;
  fargateTaskRole: IRole;
}

export class DatabaseConstruct extends Construct {
  constructor(scope: Construct, id: string, props: DatabaseConstructProps) {
    super(scope, id);

    const table = new Table(this, &#34;TodoTable&#34;, {
      partitionKey: {
        name: &#34;id&#34;,
        type: AttributeType.STRING,
      },
      tableName: props.tableName,
      billingMode: BillingMode.PAY_PER_REQUEST,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
    });

    // FargateタスクにDynamoDBへのアクセス権限を付与する
    table.grantFullAccess(props.fargateTaskRole);
  }
}
</code></pre>
<p>こちらのコードではただテーブルを作成するだけではなく、<code>table.grantFullAccess</code> で先程構築したFargateのタスクロールにDynamoDBのアクセス権限を付与する処理も行っているのでこのコンストラクトを追加するだけでAPIでDynamoDBの操作をすることができるようになります。</p>
<p>作成したコンストラクトをCDKで呼び出すために、 <code>lib/cdk-handson-stack.ts</code> の頭に＋がついている行を追加します。(＋は入れないでください！！)</p>
<pre><code>import * as cdk from &#39;aws-cdk-lib&#39;;
import { Construct } from &#39;constructs&#39;;
import { ApiConstruct } from &#39;./constructs/api-construct&#39;;
+import { DatabaseConstruct } from &#39;./constructs/database-construct&#39;;

export class CdkHandsonStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const tableName = &#39;cdk-handson-todo&#39;;

    // API Construct
    const api = new ApiConstruct(this, &#39;Api&#39;, {
      tableName: tableName
    })

+    // Database Construct
+    new DatabaseConstruct(this, &#39;Database&#39;, {
+      tableName: tableName,
+      fargateTaskRole: api.fargateTaskRole
+    })
  }
}
</code></pre>
<p>ここでは、先程作成したAPIスタックの中からFargateのタスクロールのオブジェクトを取得してDatabaseスタックにわたすようにすることで、DatabaseスタックでDynamoDBを操作するためのロールを追加することができるようになります。</p>
<p>このように他のスタックで生成されたリソースを参照することが直感的なのもCDKの魅力の一つです。</p>
<h2 is-upgraded>差分確認</h2>
<p>実際にデプロイを行う前にデプロイを実行するとどんなリソースが作成されるか差分を確認してみます。CDKでは既存のリソースとデプロイされてないリソースで差分を取れるように <code>diff</code> コマンドが用意されています。</p>
<p>以下のコマンドを実行するとデプロイ済みのリソースとの差分を確認することができます。</p>
<pre><code>cdk diff</code></pre>
<p>実行すると以下のように差分が表示されます。</p>
<pre><code>Stack CdkHandsonStack
IAM Statement Changes
┌───┬───────────────────────────┬────────┬────────────┬────────────────────────────────────────────┬───────────┐
│   │ Resource                  │ Effect │ Action     │ Principal                                  │ Condition │
├───┼───────────────────────────┼────────┼────────────┼────────────────────────────────────────────┼───────────┤
│ + │ ${Database/TodoTable.Arn} │ Allow  │ dynamodb:* │ AWS:${Api/FargateService/TaskDef/TaskRole} │           │
└───┴───────────────────────────┴────────┴────────────┴────────────────────────────────────────────┴───────────┘
(NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299)

Resources
[+] AWS::IAM::Policy Api/FargateService/TaskDef/TaskRole/DefaultPolicy ApiFargateServiceTaskDefTaskRoleDefaultPolicyA030C29D
[+] AWS::DynamoDB::Table Database/TodoTable DatabaseTodoTable3E2AC78E
[~] AWS::ECS::Service Api/FargateService/Service/Service ApiFargateService536738D3
 └─ [~] DependsOn
     └─ @@ -1,5 +1,6 @@
        [ ] [
        [ ]   &#34;ApiFargateServiceLBPublicListenerA8805410&#34;,
        [ ]   &#34;ApiFargateServiceLBPublicListenerECSGroupEB644372&#34;,
        [-]   &#34;ApiFargateServiceTaskDefTaskRole64DE2B20&#34;
        [+]   &#34;ApiFargateServiceTaskDefTaskRole64DE2B20&#34;,
        [+]   &#34;ApiFargateServiceTaskDefTaskRoleDefaultPolicyA030C29D&#34;
        [ ] ]
[~] AWS::EC2::SecurityGroup Api/FargateService/Service/SecurityGroup ApiFargateServiceSecurityGroup57582F8D
 └─ [~] DependsOn
     └─ @@ -1,3 +1,4 @@
        [ ] [
        [-]   &#34;ApiFargateServiceTaskDefTaskRole64DE2B20&#34;
        [+]   &#34;ApiFargateServiceTaskDefTaskRole64DE2B20&#34;,
        [+]   &#34;ApiFargateServiceTaskDefTaskRoleDefaultPolicyA030C29D&#34;
        [ ] ]
[~] AWS::EC2::SecurityGroupIngress Api/FargateService/Service/SecurityGroup/from CdkHandsonStackApiFargateServiceLBSecurityGroup11220BEC:8000 ApiFargateServiceSecurityGroupfromCdkHandsonStackApiFargateServiceLBSecurityGroup11220BEC800079B34DEE
 └─ [~] DependsOn
     └─ @@ -1,3 +1,4 @@
        [ ] [
        [-]   &#34;ApiFargateServiceTaskDefTaskRole64DE2B20&#34;
        [+]   &#34;ApiFargateServiceTaskDefTaskRole64DE2B20&#34;,
        [+]   &#34;ApiFargateServiceTaskDefTaskRoleDefaultPolicyA030C29D&#34;
        [ ] ]



✨  Number of stacks with differences: 1
</code></pre>
<p>差分からDynamoDBのテーブルだけではなくFargateタスク用のDynamoDBのIAMポリシーがデプロイすると追加されることが確認できます。</p>
<h2 is-upgraded>デプロイ</h2>
<p>それでは、更新したスタックをデプロイしていきます。以下のコマンドでデプロイを行います。</p>
<pre><code>cdk deploy</code></pre>
<p>デプロイ後以下の表示が出たら、デプロイは正常に成功しています。</p>
<pre><code> ✅  CdkHandsonStack

✨  Deployment time: 35.54s
</code></pre>
<h2 is-upgraded>動作確認</h2>
<p>デプロイが完了したので動作確認です。</p>
<p>APIスタックの動作確認で使用したAPIドキュメントからAPIの動作確認をします。</p>
<p>まずはデータを登録するために <code>POST /message</code> のアコーディオンを開いて、左側の <code>Try it out</code> ボタンをクリックします。クリックすると以下のリクエストボディの編集画面が表示されるので、<code>message</code> の値を好きな文字列に書き換えて、 <code>Execute</code> ボタンをクリックします。</p>
<p class="image-container"><img style="width: 601.70px" src="img/ba90d38c6d05a8a6.png"></p>
<p>実行後以下のようにステータスコード <code>500</code> だったAPIが <code>200</code> を返すようになればデプロイは成功です。もし、失敗するようであればAWSのコンソールのFargateタスクからAPIのログを確認して見てください。</p>
<p class="image-container"><img style="width: 601.70px" src="img/25915864bf04d0d8.png"></p>
<p>同様の手順で <code>GET /messages</code> を実行すると以下のようにデータベースに登録したメッセージを取得することができます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/84301b3493f0d46.png"></p>
<p>このレスポンスにある <code>id</code> の値をコピーして <code>DELETE /message</code> のパラメータに貼り付けて実行するとデータを削除することができます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/a341b88d6dcf66ea.png"></p>
<p>これで一通りAPIの動作確認ができてAPIは完成です。APIはできたので次のステップではフロントエンドをデプロイしてTodoアプリを動かせるようにします。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Step3. フロントエンドのデプロイ" duration="0">
        <p>このハンズオンの最後のステップとしてフロントエンドをデプロイするためのコンストラクトを作成していきます。フロントエンドの表示にはS3にフロントエンドのコードを格納してCloudFrontでホスティングしていきます。</p>
<h2 is-upgraded>ソースコードをダウンロード</h2>
<p>前のページで作成したCDKアプリのディレクトリ( <code>cdk-handson</code> )上で以下のコマンドを実行してAPIのソースコードをダウンロードして展開します。</p>
<pre><code>wget -O todo-app.zip https://github.com/Miura55/jawsug-nagoya-cdk-handson/releases/download/v1.0.0/todo-app-asset-v1.0.0.zip
unzip todo-app.zip</code></pre>
<p>展開して以下のように <code>cdk-handson</code> 配下に <code>todo-app</code> ディレクトリが作成されたら問題ありません。</p>
<p class="image-container"><img style="width: 268.00px" src="img/6d3fd70ed5a6aa56.png"></p>
<h2 is-upgraded>フロントエンドのモジュールをインストール</h2>
<p>次の作業をする前にフロントエンドのモジュールをインストールします。 以下のコマンドで<code>todo-app</code> ディレクトリに移動し、必要なモジュールをインストールします。</p>
<pre><code>cd todo-app
yarn install</code></pre>
<h2 is-upgraded>フロントエンドのビルド</h2>
<p>フロントエンドにはReactを使用しており、CloudFrontで静的ファイルをホスティングするためにはビルドする必要があります。このとき、APIをデプロイした時にメモしたAPI Gatewayのエンドポイントを環境変数に設定する必要があります。</p>
<p>ビルドする時に使う環境変数は <code>cdk-handson/todo-app</code> 内の <code>.env.production.local</code> に以下の変更を加えます。</p>
<pre><code>VITE_API_ENDPOINT=【APIスタックで作成したエンドポイント】</code></pre>
<p>これでビルドするための準備ができたので、<code>cdk-handson/todo-app</code> 上で以下のコマンドでビルドを実行します。</p>
<pre><code>yarn build</code></pre>
<p>コマンド終了後に <code>todo-app</code> ディレクトリ上に <code>build</code> ディレクトリが作成されていたらビルドは正常に完了しています。</p>
<p class="image-container"><img style="width: 280.00px" src="img/e7455d97d9dd363.png"></p>
<h2 is-upgraded>フロントエンドを構築するコンストラトのコード</h2>
<p>以下のコマンドでコンストラクトのコードを新規作成します。</p>
<pre><code>cd /home/ec2-user/cdk-handson
touch lib/constructs/frontend-construct.ts</code></pre>
<p><code>lib/constructs/frontend-construct.ts</code> に以下のコードを書いて保存します。</p>
<pre><code>import * as cdk from &#39;aws-cdk-lib&#39;;
import { Construct } from &#39;constructs&#39;;
import { Bucket } from &#39;aws-cdk-lib/aws-s3&#39;;
import { Distribution, OriginAccessIdentity, PriceClass, ViewerProtocolPolicy } from &#39;aws-cdk-lib/aws-cloudfront&#39;;
import { S3BucketOrigin } from &#39;aws-cdk-lib/aws-cloudfront-origins&#39;;
import { Effect, PolicyStatement } from &#39;aws-cdk-lib/aws-iam&#39;;
import { BucketDeployment, Source } from &#39;aws-cdk-lib/aws-s3-deployment&#39;;

interface FrontendConstructProps extends cdk.StackProps {
  apiEndpoint: string;
}

export class FrontendConstruct extends Construct {
  constructor(scope: Construct, id: string, props: FrontendConstructProps) {
    super(scope, id);

    const webBucket = new Bucket(this, &#39;WebBucket&#39;, {
      websiteIndexDocument: &#39;index.html&#39;,
      websiteErrorDocument: &#39;index.html&#39;,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: true,
    });
    
    // CloudFrontのOrigin Access Identityを作成する
    const websiteIdentify = new OriginAccessIdentity(this, &#39;WebsiteIdentify&#39;, {
      comment: &#39;Website identify for S3 bucket&#39;
    });
    
    
    // S3バケットへのアクセス権限を付与する
    const bucketPolicyStatement = new PolicyStatement({
      actions: [&#39;s3:GetObject&#39;],
      effect: Effect.ALLOW,
      resources: [webBucket.bucketArn + &#39;/*&#39;],
      principals: [websiteIdentify.grantPrincipal],
    });
    webBucket.addToResourcePolicy(bucketPolicyStatement);

    const webDistribution = new Distribution(this, &#39;WebDistribution&#39;, {
      defaultBehavior: {
        origin: S3BucketOrigin.withOriginAccessIdentity(webBucket, {
          originAccessIdentity: websiteIdentify,
        }),
        viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      },
      defaultRootObject: &#39;index.html&#39;,
      errorResponses: [
        {
          httpStatus: 404,
          responseHttpStatus: 200,
          responsePagePath: &#39;/index.html&#39;,
          ttl: cdk.Duration.minutes(5),
        },
        {
          httpStatus: 403,
          responseHttpStatus: 200,
          responsePagePath: &#39;/index.html&#39;,
          ttl: cdk.Duration.minutes(5),
        }
      ],
      priceClass: PriceClass.PRICE_CLASS_ALL,
    });

    // S3バケットにビルドしたフロントエンドのファイルをデプロイする
    new BucketDeployment(this, &#39;DeployWebsite&#39;, {
      sources: [Source.asset(&#39;./todo-app/build&#39;)],
      destinationBucket: webBucket,
      distribution: webDistribution,
      distributionPaths: [&#39;/*&#39;],
    });

    // CloudFrontのURLを出力する
    new cdk.CfnOutput(this, &#39;CloudFrontURL&#39;, {
      value: `https://${webDistribution.distributionDomainName}`,
    });
  }
}
</code></pre>
<p>このコードでCloudFrontのホスティング設定と先ほどビルドしたフロントエンドのコードを格納しておくS3の設定をするだけではなく、ファイルをS3にアップロードする処理も入っているので、このコンストラクトを追加するだけでWebページを表示できるようになります。</p>
<p>作成したコンストラクトをCDKで呼び出すために、 <code>lib/cdk-handson-stack.ts</code> の頭に＋がついている行を追加します。(＋は入れないでください！！)</p>
<pre><code>import * as cdk from &#39;aws-cdk-lib&#39;;
import { Construct } from &#39;constructs&#39;;
import { ApiConstruct } from &#39;./constructs/api-construct&#39;;
import { DatabaseConstruct } from &#39;./constructs/database-construct&#39;;
+import { FrontendConstruct } from &#39;./constructs/frontend-construct&#39;;

export class CdkHandsonStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const tableName = &#39;cdk-handson-todo&#39;;

    // API Construct
    const api = new ApiConstruct(this, &#39;Api&#39;, {
      tableName: tableName
    })

    // Database Construct
    new DatabaseConstruct(this, &#39;Database&#39;, {
      tableName: tableName,
      fargateTaskRole: api.fargateTaskRole
    })

+    // Frontend Construct
+    new FrontendConstruct(this, &#39;Frontend&#39;, {
+      apiEndpoint: api.apiEndpoint
+    })
  }
}
</code></pre>
<h2 is-upgraded>差分確認</h2>
<p>これでスタックを追加できたので、構築されるサービスを確認してみます。以下のコマンドで作業ディレクトリを変更して、デプロイされているサービスとの差分を確認します。</p>
<pre><code>cdk diff</code></pre>
<p>実行すると以下のように、作成されるリソースが一覧で表示されたら問題ありません。</p>
<pre><code>Stack CdkHandsonStack
IAM Statement Changes
┌───┬──────────────────────────────────────────────────────────────────────────────────────────────────┬────────┬───────────────────────────────┬────────────────────────────────────────────────────────────────────────────────┬───────────┐
│   │ Resource                                                                                         │ Effect │ Action                        │ Principal                                                                      │ Condition │
├───┼──────────────────────────────────────────────────────────────────────────────────────────────────┼────────┼───────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┼───────────┤
│ + │ ${Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole.Arn}                   │ Allow  │ sts:AssumeRole                │ Service:lambda.amazonaws.com                                                   │           │
├───┼──────────────────────────────────────────────────────────────────────────────────────────────────┼────────┼───────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┼───────────┤
│ + │ ${Custom::S3AutoDeleteObjectsCustomResourceProvider/Role.Arn}                                    │ Allow  │ sts:AssumeRole                │ Service:lambda.amazonaws.com                                                   │           │
├───┼──────────────────────────────────────────────────────────────────────────────────────────────────┼────────┼───────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┼───────────┤
│ + │ ${Frontend/WebBucket.Arn}                                                                        │ Allow  │ s3:DeleteObject*              │ AWS:${Custom::S3AutoDeleteObjectsCustomResourceProvider/Role.Arn}              │           │
│   │ ${Frontend/WebBucket.Arn}/*                                                                      │        │ s3:GetBucket*                 │                                                                                │           │
│   │                                                                                                  │        │ s3:List*                      │                                                                                │           │
│   │                                                                                                  │        │ s3:PutBucketPolicy            │                                                                                │           │
│ + │ ${Frontend/WebBucket.Arn}                                                                        │ Allow  │ s3:Abort*                     │ AWS:${Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole} │           │
│   │ ${Frontend/WebBucket.Arn}/*                                                                      │        │ s3:DeleteObject*              │                                                                                │           │
│   │                                                                                                  │        │ s3:GetBucket*                 │                                                                                │           │
│   │                                                                                                  │        │ s3:GetObject*                 │                                                                                │           │
│   │                                                                                                  │        │ s3:List*                      │                                                                                │           │
│   │                                                                                                  │        │ s3:PutObject                  │                                                                                │           │
│   │                                                                                                  │        │ s3:PutObjectLegalHold         │                                                                                │           │
│   │                                                                                                  │        │ s3:PutObjectRetention         │                                                                                │           │
│   │                                                                                                  │        │ s3:PutObjectTagging           │                                                                                │           │
│   │                                                                                                  │        │ s3:PutObjectVersionTagging    │                                                                                │           │
├───┼──────────────────────────────────────────────────────────────────────────────────────────────────┼────────┼───────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┼───────────┤
│ + │ ${Frontend/WebBucket.Arn}/*                                                                      │ Allow  │ s3:GetObject                  │ CanonicalUser:${Frontend/WebsiteIdentify.S3CanonicalUserId}                    │           │
├───┼──────────────────────────────────────────────────────────────────────────────────────────────────┼────────┼───────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┼───────────┤
│ + │ *                                                                                                │ Allow  │ cloudfront:CreateInvalidation │ AWS:${Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole} │           │
│   │                                                                                                  │        │ cloudfront:GetInvalidation    │                                                                                │           │
├───┼──────────────────────────────────────────────────────────────────────────────────────────────────┼────────┼───────────────────────────────┼────────────────────────────────────────────────────────────────────────────────┼───────────┤
│ + │ arn:${AWS::Partition}:s3:::{&#34;Fn::Sub&#34;:&#34;cdk-hnb659fds-assets-${AWS::AccountId}-${AWS::Region}&#34;}   │ Allow  │ s3:GetBucket*                 │ AWS:${Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole} │           │
│   │ arn:${AWS::Partition}:s3:::{&#34;Fn::Sub&#34;:&#34;cdk-hnb659fds-assets-${AWS::AccountId}-${AWS::Region}&#34;}/* │        │ s3:GetObject*                 │                                                                                │           │
│   │                                                                                                  │        │ s3:List*                      │                                                                                │           │
└───┴──────────────────────────────────────────────────────────────────────────────────────────────────┴────────┴───────────────────────────────┴────────────────────────────────────────────────────────────────────────────────┴───────────┘
IAM Policy Changes
┌───┬────────────────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────────────┐
│   │ Resource                                                                   │ Managed Policy ARN                                                                           │
├───┼────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤
│ + │ ${Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole} │ arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole               │
├───┼────────────────────────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤
│ + │ ${Custom::S3AutoDeleteObjectsCustomResourceProvider/Role}                  │ {&#34;Fn::Sub&#34;:&#34;arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole&#34;} │
└───┴────────────────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────────────┘
(NOTE: There may be security-related changes not in this list. See https://github.com/aws/aws-cdk/issues/1299)

Resources
[+] AWS::S3::Bucket Frontend/WebBucket FrontendWebBucket9FD9DE48
[+] AWS::S3::BucketPolicy Frontend/WebBucket/Policy FrontendWebBucketPolicy7FC230BF
[+] Custom::S3AutoDeleteObjects Frontend/WebBucket/AutoDeleteObjectsCustomResource FrontendWebBucketAutoDeleteObjectsCustomResourceFAF75BDB
[+] AWS::CloudFront::CloudFrontOriginAccessIdentity Frontend/WebsiteIdentify FrontendWebsiteIdentify80BCE072
[+] AWS::CloudFront::Distribution Frontend/WebDistribution FrontendWebDistributionD3004381
[+] AWS::Lambda::LayerVersion Frontend/DeployWebsite/AwsCliLayer FrontendDeployWebsiteAwsCliLayer326338BB
[+] Custom::CDKBucketDeployment Frontend/DeployWebsite/CustomResource FrontendDeployWebsiteCustomResource2518064E
[+] AWS::IAM::Role Custom::S3AutoDeleteObjectsCustomResourceProvider/Role CustomS3AutoDeleteObjectsCustomResourceProviderRole3B1BD092
[+] AWS::Lambda::Function Custom::S3AutoDeleteObjectsCustomResourceProvider/Handler CustomS3AutoDeleteObjectsCustomResourceProviderHandler9D90184F
[+] AWS::IAM::Role Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole CustomCDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756CServiceRole89A01265
[+] AWS::IAM::Policy Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/ServiceRole/DefaultPolicy CustomCDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756CServiceRoleDefaultPolicy88902FDF
[+] AWS::Lambda::Function Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C CustomCDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C81C01536
[+] AWS::Logs::LogGroup Custom::CDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756C/LogGroup CustomCDKBucketDeployment8693BB64968944B69AAFB0CC9EB8756CLogGroup817B64E9

Outputs
[+] Output Frontend/CloudFrontURL FrontendCloudFrontURL34A48BD2: {&#34;Value&#34;:{&#34;Fn::Join&#34;:[&#34;&#34;,[&#34;https://&#34;,{&#34;Fn::GetAtt&#34;:[&#34;FrontendWebDistributionD3004381&#34;,&#34;DomainName&#34;]}]]}}



✨  Number of stacks with differences: 1

</code></pre>
<h2 is-upgraded>デプロイ</h2>
<p>いよいよデプロイを行います。以下のコマンドで作成したスタックをデプロイします。</p>
<pre><code>cdk deploy</code></pre>
<p>これまでと同様にデプロイされるリソースの一覧が表示されて以下の確認が表示されるので <code>y</code> と入力して <code>Enter</code> を入力します。</p>
<pre><code>Do you wish to deploy these changes (y/n)? </code></pre>
<p>しばらく待つと以下のようにCloudFrontのURLが出力で表示されたらデプロイは完了です。</p>
<pre><code> ✅  CdkHandsonStack

✨  Deployment time: 310.52s

Outputs:
CdkHandsonStack.ApiApiEndpointE2C5D803 = https://ezoyc99b6b.execute-api.ap-northeast-1.amazonaws.com
CdkHandsonStack.ApiFargateServiceLoadBalancerDNSA0713F2C = CdkHan-ApiFa-jMa7BHEGxQ5a-12345678.ap-northeast-1.elb.amazonaws.com
CdkHandsonStack.ApiFargateServiceServiceURL303D0D20 = http://CdkHan-ApiFa-jMa7BHEGxQ5a-12345678.ap-northeast-1.elb.amazonaws.com
CdkHandsonStack.FrontendCloudFrontURL34A48BD2 = https://das0npkmubaka.cloudfront.net
Stack ARN:
arn:aws:cloudformation:ap-northeast-1:123456789012:stack/CdkHandsonStack/a2c48010-8ced-11f0-b769-0a0830b6a99d

✨  Total time: 322.83s

</code></pre>
<h2 is-upgraded>動作確認</h2>
<p>デプロイができたところで動作確認です。先程スタックをデプロイしたときの出力にあった、 <code>CdkHandsonFrontendStack.CloudFrontURL</code> の値にあるCloudFrontのURLをブラウザで開いて以下のようにTodoアプリが表示されたらフロントエンドのデプロイは正常に完了です。</p>
<p class="image-container"><img style="width: 539.00px" src="img/4b1b9fc966c170be.png"></p>
<p>今回のハンズオンで構築するアプリケーションはこれで完成です。お疲れ様でした！</p>
<p>ここまでできたら、最後に片付けを行います。次のページで片付けの方法を紹介します。</p>


      </google-codelab-step>
    
      <google-codelab-step label="片付け" duration="0">
        <p>最後にハンズオンの片付けを行います。 このハンズオンでは有料のサービスが使われているため、放置しておくとかなりの金額になるので、ハンズオン終了後に忘れずに片付けを行いましょう。</p>
<h2 is-upgraded>CDKで構築したリソースの削除</h2>
<p>CDKで構築したリソースは以下のコマンドですべて削除することができます。</p>
<pre><code>cdk destroy</code></pre>
<p>最終的に以下のように表示されたらリソースの削除は完了です</p>
<pre><code>CdkHandsonStack: destroying... [1/1]

 ✅  CdkHandsonStack: destroyed
</code></pre>
<h2 is-upgraded>code-serverを削除</h2>
<p>続いて、EC2で立てたcode-serverを削除していきます。CloudFormationから削除できますが、CloudFormationをデプロイするときに使用したスクリプトに削除するためのオプションも用意しています。</p>
<p>CloudShellを開き、以下のコマンドでcode-serverのスタックを削除することが出来ます。</p>
<pre><code>cd /home/cloudshell-user/ec2-code-server
./deploy.sh delete</code></pre>
<p>プロンプトで確認の表示がでるので、 <code>y</code> を入力します。その後、以下の表示が出たら削除の処理が実行されています。</p>
<pre><code>[INFO] Stack deletion initiated</code></pre>
<p>スタックの状況は以下のコマンドを実行することで確認できます。 実行結果が <code>Stack not found</code> と表示されていればスタックは正常に削除されています。</p>
<pre><code>./deploy.sh status</code></pre>
<h2 is-upgraded>Bootstrapで作成されたアセットの削除(CDKを使っている方は削除しないでください)</h2>
<p>今回のハンズオンのときにBootstrapで作成したアセットは残しててもお金がかかることはありませんが整理のために削除しておくといいです。アセットを保存しているリソースはCloudFormationでまとめて削除できますが、リソースの中身を削除しないとエラーになるので予め削除してからリソースを一括で削除するので順番に削除していきます。</p>
<aside class="warning"><p>CDKを使う予定がある方や現在CDKを使っている方は次にCDKを使うときにエラーになるので絶対にアセットを削除しないでください。</p>
</aside>
<h3 is-upgraded>ECRの中身を削除</h3>
<p>AWSのコンソールでECRを開き Repositoriesをクリックします。</p>
<p class="image-container"><img style="width: 601.70px" src="img/c524c1f74bc60a6.png"></p>
<p><code>cdk-</code> から始まるレポジトリを開きます。</p>
<p class="image-container"><img style="width: 601.70px" src="img/475416c154c988ab.png"></p>
<p>レポジトリ内に保存されているイメージにすべてチェックを入れて削除します。</p>
<p class="image-container"><img style="width: 601.70px" src="img/eeeb614fdf56e34f.png"></p>
<p>以上でECRのアセットの削除は完了です。</p>
<h3 is-upgraded>S3の中身を削除</h3>
<p>続いてS3のアセットを削除します。</p>
<p>AWSのコンソールから <code>cdk-</code> から始まるバケットを選択して【空にする】を選択します。</p>
<p class="image-container"><img style="width: 601.70px" src="img/fb03e3145106e295.png"></p>
<p>これでS3のアセットの削除は完了です。</p>
<h3 is-upgraded>CloudFormationでスタックを削除</h3>
<p>最後にCloudFormationでCDKに使われていたスタックを削除していきます。AWSのコンソール画面からCloudFormationを開き、 <code>CDKToolkit</code> を選択して【削除】をクリックします。</p>
<p class="image-container"><img style="width: 601.70px" src="img/161186b54332030.png"></p>
<p>リロードボタンを押して、CDKToolkitの表示が消えたらスタックの削除は完了です。</p>
<p class="image-container"><img style="width: 601.70px" src="img/4e4c53d4400fe81c.png"></p>
<h2 is-upgraded>まとめ</h2>
<p>今回はCDKを使用してAWS上で動作するアプリケーションを構築していく流れを体験していただきました。CDKを使うことでAWSのコンソールを開かなくてもアプリケーションの構築が簡単にできることがお分かりいただけたと思います。</p>
<p>CDKはコードでAWSのリソースを定義するだけではなく、アプリケーションのデプロイをサポートする機能も充実しているので使いこなすことでかなり開発効率が上がります。</p>
<p>また削除のときにS3のバケットの中身を完全に削除できたりするなど、CloudFormationだとできない機能もあるのもCDKの魅力の一つです。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Appendix" duration="0">
        <p>ここでは本編に関連した内容についてひたすら解説していきます。</p>
<h2 is-upgraded>今回のハンズオンで作ったソースコード</h2>
<p>今回のハンズオンのソースコードは以下のGithubレポジトリで公開しているのでハンズオンの復習に是非ご活用ください。また、ローカルの環境構築を簡単にできるDevcontainerの設定ファイルも用意しています。</p>
<p><a href="https://github.com/Miura55/jawsug-nagoya-cdk-handson" target="_blank">https://github.com/Miura55/jawsug-nagoya-cdk-handson</a></p>
<h3 is-upgraded>APIのコードについて軽く解説</h3>
<p class="image-container"><img style="width: 601.70px" src="img/a1beb692b5b79c5b.png"></p>
<p>今回のハンズオンではFastAPIというPythonのWebフレームワークを使ってAPIを作成しています。FastAPIはPythonのWebフレームワークの中では比較的新しいフレームワークで、非同期処理に対応しています。Flaskに近い記法なのでFlask触ったことある方なら同じ感覚でAPIを実装できます。</p>
<p>ハンズオンではAPIの動作確認にAPIドキュメントを使用していますが、これはFastAPIのデフォルトの機能として提供されており、リクエストとレスポンスのスキーマをAPIごとに定義するだけで効率よくAPIドキュメントを作ることができます。</p>
<p>今回は取り上げませんでしたが、APIにデプロイするコンテナをローカルで確認できるように <code>api</code> ディレクトリ内にdocker-compose.yamlがあるので動作確認が手軽にできるようになります。</p>
<h3 is-upgraded>フロントエンドのコードについて軽く解説</h3>
<p class="image-container"><img style="width: 601.70px" src="img/f60645b59446e824.png"></p>
<p>フロントエンドにはフレームワークにReact、ビルドにViteを使用しています。ViteはWebpackに変わる比較的新しめのビルドツールでフランス語で「素早い」という意味があるようにビルドを高速化させることができます。</p>
<p>ローカルでの動作確認するときと本番用にビルドするときで環境変数を使い分けることができるので、APIのURLなどを環境変数として定義すれば開発効率が上がります。今回のコードでは <code>todo-app/.env</code> で設定しているURLがローカル用、 <code>todo-app/.env.production.local</code> で設定しているURLがAWSのAPI Gateway用に設定するようにしています。ローカルのAPIについてはFastAPIのときに紹介したdocker-compose.yamlやDevcontainerで動かしてください。</p>
<p>日本語のドキュメントがかなり充実しているので興味のある方は <a href="https://ja.vitejs.dev/guide/" target="_blank">https://ja.vitejs.dev/guide/</a> をチェックしてみてください。</p>
<h2 is-upgraded>CDKのリソース名を環境ごとに切り分ける</h2>
<p>CDKはただコードで環境構築できるだけじゃなくて同じ構成で複数の環境を用意できるのも特徴です。複数の環境に分けるときにはリソース名を環境ごとに指定したいときがあります(APIのドメイン設定とか)。よくあるやり方だと.envとかを使って環境変数を使いがちですが、CDKを使うときにはそのようなユースケースで役に立つ <strong>context</strong> というものがあります。</p>
<p>contextはCDKのプロジェクトを作成したときに作られる <code>cdk.json</code> に以下のように環境ごとにリソース名を設定する事ができます。アクセストークンなどの機密情報でなければこのやり方だと効率よく変数管理できます。</p>
<pre><code>  &#34;context&#34;: {
    ...
    &#34;environment&#34;: &#34;dev&#34;,
    &#34;dev&#34; : {
      &#34;account&#34;: &#34;123456789011&#34;,
      &#34;region&#34;: &#34;ap-northeast-1&#34;
    },
    &#34;prod&#34; : {
      &#34;account&#34;: &#34;123456789012&#34;,
      &#34;region&#34;: &#34;ap-northeast-1&#34;
    }
  }
</code></pre>
<p>上記の設定であればスタックのコードでは以下の記述をすると環境ごとの設定値を簡単に呼び出せます。</p>
<pre><code>const environment = this.node.tryGetContext(&#39;environment&#39;);
const context = this.node.tryGetContext(environment);</code></pre>
<p>また、<code>bin</code> ディレクトリ以下のスタックを定義するコード(今回であれば <code>bin/cdk-handson.ts</code> )でcontextを使いたいときは以下のコードで呼び出せます。</p>
<pre><code>const environment = app.node.tryGetContext(&#39;environment&#39;);
const context = app.node.tryGetContext(envrionment);</code></pre>
<p>そして環境を指定してデプロイするときは以下のコマンドでデプロイできます。今回取り上げた例のようにAWSのアカウントを切り替えるときは <code>--profile</code> オプションを付けてprofile名も指定する必要があります。</p>
<pre><code>cdk deploy -c environment=dev --profile [profile_name]</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
